{"abi":[{"type":"function","name":"sendMessage","inputs":[{"name":"payload","type":"bytes","internalType":"bytes"},{"name":"refundRecipient","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"payable"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"sendMessage(bytes,address)":"f20755ba"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"refundRecipient\",\"type\":\"address\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"This interface abstracts the details of the underlying General Purpose Message Passing protocol.      This minimizes changes to the interface consumer if the underlying GMP is changed in the future.      In addition, this interface is not specific to an ERC20 bridge, and will likely eventually be renamed to be more generic.\",\"kind\":\"dev\",\"methods\":{\"sendMessage(bytes,address)\":{\"details\":\"The function is `payable` because the message passing protocol may require a fee to be paid.\",\"params\":{\"payload\":\"The message to send, encoded in a `bytes` array.\",\"refundRecipient\":\"Used if the message passing protocol requires fees & pays back excess to a refund recipient.\"}}},\"title\":\"Root ERC20 Bridge Adaptor Interface\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"sendMessage(bytes,address)\":{\"notice\":\"Send an arbitrary message to the child chain via the message passing protocol.\"}},\"notice\":\"Defines the functions that can be used be used by a Root ERC20 Bridge to send messages through an underlying GMP\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/interfaces/root/IRootBridgeAdaptor.sol\":\"IRootBridgeAdaptor\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@axelar-cgp-solidity/=lib/axelar-cgp-solidity/\",\":@axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/\",\":@axelar-network/axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/\",\":@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\":@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\":@perimetersec/fuzzlib/src/=node_modules/@perimetersec/fuzzlib/src/\",\":axelar-cgp-solidity/=lib/axelar-cgp-solidity/contracts/\",\":axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/contracts/\",\":ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/openzeppelin-contracts/contracts/\"]},\"sources\":{\"src/interfaces/root/IRootBridgeAdaptor.sol\":{\"keccak256\":\"0x23bb38f4fdac6fc66b955336cc01e63cd8953d47c40a244b4eecdbebc471b8a0\",\"license\":\"Apache 2.0\",\"urls\":[\"bzz-raw://9bdb657106e8d263cccf0ce3130a699f9761c46b875a602f68e734a89d8e22f1\",\"dweb:/ipfs/QmYyQ53E4EisUpDqQVWxLf6tQng1k1G8hxD2Z97dhqDw27\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.19+commit.7dd6d404"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"},{"internalType":"address","name":"refundRecipient","type":"address"}],"stateMutability":"payable","type":"function","name":"sendMessage"}],"devdoc":{"kind":"dev","methods":{"sendMessage(bytes,address)":{"details":"The function is `payable` because the message passing protocol may require a fee to be paid.","params":{"payload":"The message to send, encoded in a `bytes` array.","refundRecipient":"Used if the message passing protocol requires fees & pays back excess to a refund recipient."}}},"version":1},"userdoc":{"kind":"user","methods":{"sendMessage(bytes,address)":{"notice":"Send an arbitrary message to the child chain via the message passing protocol."}},"version":1}},"settings":{"remappings":["@axelar-cgp-solidity/=lib/axelar-cgp-solidity/","@axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/","@axelar-network/axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/","@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/","@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","@perimetersec/fuzzlib/src/=node_modules/@perimetersec/fuzzlib/src/","axelar-cgp-solidity/=lib/axelar-cgp-solidity/contracts/","axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/contracts/","ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin/=lib/openzeppelin-contracts/contracts/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"src/interfaces/root/IRootBridgeAdaptor.sol":"IRootBridgeAdaptor"},"evmVersion":"paris","libraries":{}},"sources":{"src/interfaces/root/IRootBridgeAdaptor.sol":{"keccak256":"0x23bb38f4fdac6fc66b955336cc01e63cd8953d47c40a244b4eecdbebc471b8a0","urls":["bzz-raw://9bdb657106e8d263cccf0ce3130a699f9761c46b875a602f68e734a89d8e22f1","dweb:/ipfs/QmYyQ53E4EisUpDqQVWxLf6tQng1k1G8hxD2Z97dhqDw27"],"license":"Apache 2.0"}},"version":1},"id":64}