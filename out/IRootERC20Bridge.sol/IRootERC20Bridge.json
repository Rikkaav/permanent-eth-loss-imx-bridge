{"abi":[{"type":"function","name":"deposit","inputs":[{"name":"rootToken","type":"address","internalType":"contract IERC20Metadata"},{"name":"amount","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"payable"},{"type":"function","name":"depositETH","inputs":[{"name":"amount","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"payable"},{"type":"function","name":"depositTo","inputs":[{"name":"rootToken","type":"address","internalType":"contract IERC20Metadata"},{"name":"receiver","type":"address","internalType":"address"},{"name":"amount","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"payable"},{"type":"function","name":"depositToETH","inputs":[{"name":"receiver","type":"address","internalType":"address"},{"name":"amount","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"payable"},{"type":"function","name":"grantVariableManagerRole","inputs":[{"name":"account","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"mapToken","inputs":[{"name":"rootToken","type":"address","internalType":"contract IERC20Metadata"}],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"payable"},{"type":"function","name":"onMessageReceive","inputs":[{"name":"data","type":"bytes","internalType":"bytes"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"revokeVariableManagerRole","inputs":[{"name":"account","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"updateRootBridgeAdaptor","inputs":[{"name":"newRootBridgeAdaptor","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"deposit(address,uint256)":"47e7ef24","depositETH(uint256)":"5358fbda","depositTo(address,address,uint256)":"f213159c","depositToETH(address,uint256)":"e0410432","grantVariableManagerRole(address)":"07b2b7ad","mapToken(address)":"f4a120f7","onMessageReceive(bytes)":"7248c77c","revokeVariableManagerRole(address)":"6066ae87","updateRootBridgeAdaptor(address)":"a8deae56"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IERC20Metadata\",\"name\":\"rootToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Metadata\",\"name\":\"rootToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantVariableManagerRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Metadata\",\"name\":\"rootToken\",\"type\":\"address\"}],\"name\":\"mapToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onMessageReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeVariableManagerRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRootBridgeAdaptor\",\"type\":\"address\"}],\"name\":\"updateRootBridgeAdaptor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Features:     - Maps tokens from the root chain to the child chain.     - Deposits tokens from the root chain to the child chain.     - Deposits native ETH from the root chain to the child chain.\",\"kind\":\"dev\",\"methods\":{\"deposit(address,uint256)\":{\"custom:requires\":\"`rootToken` should already have been mapped with `mapToken()`.\",\"details\":\"The function is `payable` because the message passing protocol requires a fee to be paid.\",\"params\":{\"amount\":\"The amount of tokens to deposit.\",\"rootToken\":\"The address of the token on the root chain.\"}},\"depositETH(uint256)\":{\"details\":\"The function is `payable` because the message passing protocol requires a fee to be paid.the `msg.value` provided should cover the amount to send as well as the bridge fee.\",\"params\":{\"amount\":\"The amount of tokens to deposit.\"}},\"depositTo(address,address,uint256)\":{\"custom:requires\":\"`rootToken` should already have been mapped with `mapToken()`.\",\"details\":\"The function is `payable` because the message passing protocol requires a fee to be paid.\",\"params\":{\"amount\":\"The amount of tokens to deposit.\",\"receiver\":\"The address of the receiver on the child chain, to credit tokens to.\",\"rootToken\":\"The address of the token on the root chain.\"}},\"depositToETH(address,uint256)\":{\"details\":\"The function is `payable` because the message passing protocol requires a fee to be paid.the `msg.value` provided should cover the amount to send as well as the bridge fee.\",\"params\":{\"amount\":\"The amount of tokens to deposit.\",\"receiver\":\"The address of the receiver on the child chain.\"}},\"mapToken(address)\":{\"details\":\"The function:      - fails with a `AlreadyMapped` error if the token has already been mapped.      - populates a root token => child token mapping on the root chain before        sending a message telling the child chain to do the same.      - is `payable` because the message passing protocol requires a fee to be paid.The address of the child chain token is deterministic using CREATE2.\",\"params\":{\"rootToken\":\"The address of the token on the root chain.\"},\"returns\":{\"_0\":\"childToken The address of the token to be deployed on the child chain.\"}},\"onMessageReceive(bytes)\":{\"details\":\"This function is called by the underlying bridge adaptor on the root chain, when it receives a validated message from the GMP.         It assumes that the underlying adaptor has already validated the sender chain and sender address.\",\"params\":{\"data\":\"The data payload of the message.\"}},\"updateRootBridgeAdaptor(address)\":{\"details\":\"Can only be called by ADAPTOR_MANAGER_ROLE.\",\"params\":{\"newRootBridgeAdaptor\":\"Address of new root bridge adaptor.\"}}},\"title\":\"Root ERC20 Bridge Interface\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"deposit(address,uint256)\":{\"notice\":\"Deposit tokens to the bridge and issue corresponding tokens to `msg.sender` on the child chain.\"},\"depositETH(uint256)\":{\"notice\":\"Deposit ETH to the bridge and issue corresponding wrapped ETH to `msg.sender` on the child chain.\"},\"depositTo(address,address,uint256)\":{\"notice\":\"Deposit tokens to the bridge and issue corresponding tokens to `receiver` address on the child chain.\"},\"depositToETH(address,uint256)\":{\"notice\":\"Deposit ETH to the bridge and issue corresponding wrapped ETH to `receiver` address on the child chain.\"},\"grantVariableManagerRole(address)\":{\"notice\":\"Function to grant `VARIABLE_MANAGER_ROLE` role to an address\"},\"mapToken(address)\":{\"notice\":\"Initiates sending a mapToken message to the child chain, if the token hasn't been mapped before.         This operation requires the `rootToken` to have the following public getter functions: `name()`, `symbol()`, and `decimals()`.         These functions are optional in the ERC20 standard. If the token does not provide these functions,         the mapping operation will fail and return a `TokenNotSupported` error.\"},\"onMessageReceive(bytes)\":{\"notice\":\"Receives a bridge message from the child chain.\"},\"revokeVariableManagerRole(address)\":{\"notice\":\"Function to revoke `VARIABLE_MANAGER_ROLE` role from an address\"},\"updateRootBridgeAdaptor(address)\":{\"notice\":\"Updates the root bridge adaptor.\"}},\"notice\":\"Defines the key functions of an ERC20 bridge on the root chain, which enables bridging of standard ERC20 tokens, ETH, wETH, IMX and wIMX from the root chain to the child chain and back.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/interfaces/root/IRootERC20Bridge.sol\":\"IRootERC20Bridge\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@axelar-cgp-solidity/=lib/axelar-cgp-solidity/\",\":@axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/\",\":@axelar-network/axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/\",\":@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\":@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\":@perimetersec/fuzzlib/src/=node_modules/@perimetersec/fuzzlib/src/\",\":axelar-cgp-solidity/=lib/axelar-cgp-solidity/contracts/\",\":axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/contracts/\",\":ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/openzeppelin-contracts/contracts/\"]},\"sources\":{\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\":{\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bd39944e8fc06be6dbe2dd1d8449b5336e23c6a7ba3e8e9ae5ae0f37f35283f5\",\"dweb:/ipfs/QmPV3FGYjVwvKSgAXKUN3r9T9GwniZz83CxBpM7vyj2G53\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://5a376d3dda2cb70536c0a45c208b29b34ac560c4cb4f513a42079f96ba47d2dd\",\"dweb:/ipfs/QmZQg6gn1sUpM8wHzwNvSnihumUCAhxD119MpXeKp8B9s8\"]},\"src/interfaces/root/IRootERC20Bridge.sol\":{\"keccak256\":\"0x677cd18d530214f437bb447017919826a1d7ef9da8040a1954e9b90169513d84\",\"license\":\"Apache 2.0\",\"urls\":[\"bzz-raw://bf121bba236ed3a04e4e773096934f4544408e7a9476ac6d66af10c5f0ce9224\",\"dweb:/ipfs/QmPje2pPtbfDSNGDPGjBj4n4YSoc9KeBUXBvSeSVc9DiA5\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.19+commit.7dd6d404"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"contract IERC20Metadata","name":"rootToken","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"payable","type":"function","name":"deposit"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"payable","type":"function","name":"depositETH"},{"inputs":[{"internalType":"contract IERC20Metadata","name":"rootToken","type":"address"},{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"payable","type":"function","name":"depositTo"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"payable","type":"function","name":"depositToETH"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"grantVariableManagerRole"},{"inputs":[{"internalType":"contract IERC20Metadata","name":"rootToken","type":"address"}],"stateMutability":"payable","type":"function","name":"mapToken","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[{"internalType":"bytes","name":"data","type":"bytes"}],"stateMutability":"nonpayable","type":"function","name":"onMessageReceive"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"revokeVariableManagerRole"},{"inputs":[{"internalType":"address","name":"newRootBridgeAdaptor","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"updateRootBridgeAdaptor"}],"devdoc":{"kind":"dev","methods":{"deposit(address,uint256)":{"custom:requires":"`rootToken` should already have been mapped with `mapToken()`.","details":"The function is `payable` because the message passing protocol requires a fee to be paid.","params":{"amount":"The amount of tokens to deposit.","rootToken":"The address of the token on the root chain."}},"depositETH(uint256)":{"details":"The function is `payable` because the message passing protocol requires a fee to be paid.the `msg.value` provided should cover the amount to send as well as the bridge fee.","params":{"amount":"The amount of tokens to deposit."}},"depositTo(address,address,uint256)":{"custom:requires":"`rootToken` should already have been mapped with `mapToken()`.","details":"The function is `payable` because the message passing protocol requires a fee to be paid.","params":{"amount":"The amount of tokens to deposit.","receiver":"The address of the receiver on the child chain, to credit tokens to.","rootToken":"The address of the token on the root chain."}},"depositToETH(address,uint256)":{"details":"The function is `payable` because the message passing protocol requires a fee to be paid.the `msg.value` provided should cover the amount to send as well as the bridge fee.","params":{"amount":"The amount of tokens to deposit.","receiver":"The address of the receiver on the child chain."}},"mapToken(address)":{"details":"The function:      - fails with a `AlreadyMapped` error if the token has already been mapped.      - populates a root token => child token mapping on the root chain before        sending a message telling the child chain to do the same.      - is `payable` because the message passing protocol requires a fee to be paid.The address of the child chain token is deterministic using CREATE2.","params":{"rootToken":"The address of the token on the root chain."},"returns":{"_0":"childToken The address of the token to be deployed on the child chain."}},"onMessageReceive(bytes)":{"details":"This function is called by the underlying bridge adaptor on the root chain, when it receives a validated message from the GMP.         It assumes that the underlying adaptor has already validated the sender chain and sender address.","params":{"data":"The data payload of the message."}},"updateRootBridgeAdaptor(address)":{"details":"Can only be called by ADAPTOR_MANAGER_ROLE.","params":{"newRootBridgeAdaptor":"Address of new root bridge adaptor."}}},"version":1},"userdoc":{"kind":"user","methods":{"deposit(address,uint256)":{"notice":"Deposit tokens to the bridge and issue corresponding tokens to `msg.sender` on the child chain."},"depositETH(uint256)":{"notice":"Deposit ETH to the bridge and issue corresponding wrapped ETH to `msg.sender` on the child chain."},"depositTo(address,address,uint256)":{"notice":"Deposit tokens to the bridge and issue corresponding tokens to `receiver` address on the child chain."},"depositToETH(address,uint256)":{"notice":"Deposit ETH to the bridge and issue corresponding wrapped ETH to `receiver` address on the child chain."},"grantVariableManagerRole(address)":{"notice":"Function to grant `VARIABLE_MANAGER_ROLE` role to an address"},"mapToken(address)":{"notice":"Initiates sending a mapToken message to the child chain, if the token hasn't been mapped before.         This operation requires the `rootToken` to have the following public getter functions: `name()`, `symbol()`, and `decimals()`.         These functions are optional in the ERC20 standard. If the token does not provide these functions,         the mapping operation will fail and return a `TokenNotSupported` error."},"onMessageReceive(bytes)":{"notice":"Receives a bridge message from the child chain."},"revokeVariableManagerRole(address)":{"notice":"Function to revoke `VARIABLE_MANAGER_ROLE` role from an address"},"updateRootBridgeAdaptor(address)":{"notice":"Updates the root bridge adaptor."}},"version":1}},"settings":{"remappings":["@axelar-cgp-solidity/=lib/axelar-cgp-solidity/","@axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/","@axelar-network/axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/","@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/","@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","@perimetersec/fuzzlib/src/=node_modules/@perimetersec/fuzzlib/src/","axelar-cgp-solidity/=lib/axelar-cgp-solidity/contracts/","axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/contracts/","ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin/=lib/openzeppelin-contracts/contracts/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"src/interfaces/root/IRootERC20Bridge.sol":"IRootERC20Bridge"},"evmVersion":"paris","libraries":{}},"sources":{"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"keccak256":"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305","urls":["bzz-raw://bd39944e8fc06be6dbe2dd1d8449b5336e23c6a7ba3e8e9ae5ae0f37f35283f5","dweb:/ipfs/QmPV3FGYjVwvKSgAXKUN3r9T9GwniZz83CxBpM7vyj2G53"],"license":"MIT"},"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"keccak256":"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca","urls":["bzz-raw://5a376d3dda2cb70536c0a45c208b29b34ac560c4cb4f513a42079f96ba47d2dd","dweb:/ipfs/QmZQg6gn1sUpM8wHzwNvSnihumUCAhxD119MpXeKp8B9s8"],"license":"MIT"},"src/interfaces/root/IRootERC20Bridge.sol":{"keccak256":"0x677cd18d530214f437bb447017919826a1d7ef9da8040a1954e9b90169513d84","urls":["bzz-raw://bf121bba236ed3a04e4e773096934f4544408e7a9476ac6d66af10c5f0ce9224","dweb:/ipfs/QmPje2pPtbfDSNGDPGjBj4n4YSoc9KeBUXBvSeSVc9DiA5"],"license":"Apache 2.0"}},"version":1},"id":65}